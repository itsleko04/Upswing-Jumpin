# Пояснительная записка к проекту: "Upswing Jumpin'"

## 1. Общие сведения
**Upswing Jumpin'** — это динамичный ритм-платформер на языке Python, вдохновленный классическими представителями жанра (такими как Geometry Dash). Проект разработан командой из двух человек в рамках учебного смотра знаний. Основная цель — демонстрация навыков объектно-ориентированного программирования, работы с arcade и управления игровыми состояниями.

## 2. Команда проекта
*   **Николай Липницкий (Lead Programmer)** — архитектура движка игры, логика игрока, система уровней.
*   **Диана Волкова (Programmer & Artist)** — логика геймплея, визуальное оформление.

## 3. Игровые механики
*   **Автоматическое движение:** Игрок постоянно движется вправо с заданной скоростью.
*   **Система прыжков:** Реализована механика прыжка с характерным для жанра вращением куба. При приземлении угол спрайта автоматически корректируется.
*   **Условия поражения:** Персонаж погибает при столкновении с препятствиями или падении за пределы экрана.
*   **Ритм и музыка:** Игровой процесс синхронизирован с музыкальным сопровождением. При смерти музыка останавливается, а при рестарте запускается заново.
*   **Быстрый перезапуск:** Реализован экран «Game Over», позволяющий вернуться в игру нажатием клавиши **R**.

## 1. Глобальная конфигурация (`GC.py`)
Центральный модуль управления балансом и физическими константами, используемый всеми подсистемами.

*   **Физика**: `GRAVITY` (0.5) и плавность камеры `CAMERA_LERP` (0.1).
*   **Геймплей**: `PLAYER_SPEED` (6.5), `PLAYER_JUMP_FORCE` (10) и множитель очков `SCORE_MULTIPLIER` (15).

---

## 2. Системное ядро (Engine)

### 2.1. Управление приложением (`Application.py`)
*   **Класс `Application`**: Точка входа. Управляет жизненным циклом сессии, хранит ссылку на текущее окно (`Window`) и текущие настройки. Реализует переключение между уровнями и меню.
*   **Класс `Window`**: Наследник `arcade.Window`. Перехватывает события ОС и транслирует их во внутреннюю систему ввода (`InputSystem`). Содержит событие `on_close_event` для сохранения данных перед выходом.

### 2.2. Система ввода (`InputSystem`)
Абстрактный слой, отделяющий логику от конкретной реализации фреймворка.
*   **Состояния клавиш**: Каждая клавиша (`Key`) может иметь статус `PRESSED`, `RELEASED` или `HOLDING`.
*   **InputBridge**: Предоставляет методы `on_key_down`, `on_key_up` и `on_key` для удобной проверки состояния ввода в игровом цикле.
*   **Window**: Переводит ввод из arcade-системы ввода во внутреннюю `InputSystem`

### 2.3. Событийная модель (`Events.py`)
Реализует паттерн "Наблюдатель" (`Event` и `EventWithArgs`). Позволяет подписывать методы на действия (смерть игрока, завершение уровня) без создания жестких зависимостей между классами.

---

## 3. Игровая логика (Content)

### 3.1. Базовая физика и уровни (`Level.py`, `Player.py`)
*   **Класс `Player`**: Базовый спрайт игрока. Содержит логику "заморозки" (`freeze`), автоматической смерти при падении в яму и вызова события `on_death`.
*   **Класс `Level`**: Основа игрового процесса.
    *   **Загрузка**: Использует Tilemap для разделения слоев: `collision` (коллизии), `shapes` (смертельные шипы), `jump_points` (сферы для прыжков в воздухе), `autojumpers` (батуты).
    *   **Камера**: Плавно следует за игроком, используя линейную интерполяцию (`lerp_2d`).
    *   **Таймер**: Ведет учет `gameplay_time` для расчета финального счета.

### 3.2. Режимы игрока (`PlayerModes.py`)
*   **Класс `PlayerCube`**: Специфическая реализация куба. 
    *   Реализует вращение спрайта в прыжке.
    *   Автоматически выравнивает угол наклона до 0 или 180 градусов при прекращении вращения.
    *   Управляет логикой рывка (`dashing`).

---

## 4. Интерфейс и навигация (`Menu.py` & `GameResultView.py`)

### Главный цикл навигации:
1.  **MenuView**: Стартовый экран. Кнопки «Play», «Settings», «Exit» и «Tutorial» (открывает внешний файл через `subprocess`).
2.  **SettingsView**: Экран с `UISlider` для интерактивной настройки громкости.
3.  **PlayView**: Меню выбора доступных уровней.
4.  **GameResultView**: Экран итогов, отображающий «Победу» или «Поражение».
    *   **Расчет очков**: `score = int(SCORE_MULTIPLIER * gameplay_time)`.
    *   **Оптимизация**: Использование `pyglet.graphics.Batch` для быстрого рендеринга текста.

---

## 5. Архитектурные связи
*   **Application Context**: Все представления (Views) хранят ссылку на `self.application` для доступа к глобальным методам (запуск уровня, показ меню).
*   **Event Driven**: Уровни (`TestLevel.py`) подписываются на события окончания игры, чтобы корректно очищать ресурсы (например, останавливать музыку через `theme_music_player.delete()`).

---

## Используемые технологии
*   **Базовый движок**: `arcade` (Python).
*   **Системные вызовы**: `subprocess` (для взаимодействия с файловой системой ОС).
*   **Конфигурация:** Файл `settings.ini` содержит все внешние настройки (разрешение, пути к ресурсам, громкость). Параметры громкости сохраняются динамически при закрытии приложения.

## 5. Технологический стек (2026)
*   **Язык:** Python 3.10+
*   **Движок:** [Arcade](api.arcade.academy) (использование OpenGL для высокой производительности отрисовки).
*   **Обработка данных:** `configparser` для INI-файлов.
*   **Графика и уровни:** `Tiled`.

## 6. Структура проекта
*   `main.py` — Точка входа в приложение.
*   `Assets/Scripts/Engine/` — Базовая логика: события, общие классы игрока и уровней.
*   `Assets/Scripts/Content/` — Реализация конкретных уровней и игровых объектов.
*   `Assets/GC/` — Глобальные константы (настройки скорости, силы прыжка).
*   `settings.ini` — Конфигурационный файл проекта.

## 7. Инструкция по установке и запуску
1.  Убедитесь, что у вас установлен Python 3.10 или выше.
2.  Установите необходимые зависимости:
    ```bash
    pip install arcade
    ```
3.  Разместите все файлы проекта согласно структуре папок.
4.  Запустите игру:
    ```bash
    python main.py
    ```

## 8. Управление
*   **ЛКМ / Пробел:** Прыжок.
